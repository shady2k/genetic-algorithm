# ПО для поиска глобального экстремума функции одной переменной
# Search for a global extremum of a function using genetic algorithms software
Генетический алгоритм является методом оптимизации, основанный на аналогиях с природой. С его помощью можно реализовать множество методов оптимизации, при условии, что они могут быть параметризованы так, чтобы решение задачи давало показатель того, насколько точным является решение, найденное алгоритмом. Этот показатель определяется как пригодность.

По сути, эволюция осуществляется процессом селекции, служащим типичным примером выражения «выживает сильнейший». Чтобы выбрать индивидуума, необходима популяция индивидуумов на выбор, чтобы произвести новое поколение индивидуумов.

Для любой задачи, требующей решения, необходим какой-то показатель хорошего качества решения (пригодность), т.е. чем лучше решение, тем выше пригодность, возвращенная из функции. Чем менее пригодны решения, тем меньше их шансы сохраниться до следующей популяции. Используя такой метод, алгоритм уменьшает число проверяемых им возможных решений.

Сильной стороной генетических алгоритмов является их способность решать многоэкстремальные задачи без наложения условий на вид оптимизируемой функции (отсутствуют требования на непрерывность самой функции и ее производных). Также важным достоинством генетических алгоритмов является то, что для них не важно начальное приближение.

Для разработки программного обеспечения была использована среда разработки Visual Studio 2019 на языке C# с использованием .NET Framework 4.7.8, аналогично работе [12]. Предлагаемый код алгоритма содержит несколько простых классов: Population для хранения информации о популяции; Сhromosome для записи информации о хромосоме; вспомогательный класс генератора случайных чисел.
Класс Population можно считать простым контейнером. Структура является массивом объектов Сhromosome, чисел типа double, вычисленное значение фитнесс-функции и признак «мертвой» хромосомы. Так как скрещивание и мутация происходит в геноме, оба метода находятся в этом же классе. Оператор кроссовера запускается для двух выбранных хромосом, полученный потомок добавляется в популяцию. Пригодность конкретного генома хранится в классе Сhromosome. Класс Population делает всю основную работу.
Предлагаемый генетический алгоритм состоит из следующих базовых шагов:
1. Создать новую популяцию (новый объект класса Population), проинициализировав их набором случайных хромосом с максимальным количеством initPopulationSize (рисунок 1);
2. Применить скрещивание к каждой особи популяции с заданной вероятностью crossPossibility, чтобы произвести потомство (рисунок 2);
3. Применить мутацию к каждой особи с заданной вероятностью mutationPossibility (Рисунок 3);
4. Провести селекцию, путем сортировки по наилучшей приспособленности с помощью фитнес-функции fitnessFunction;
5. Удалить наименее приспособленных потомков, если их количество больше размера популяции maxPopulationSie (метод Selection());
6. Заменить старую популяцию новой;
7. Если не было произведено достаточно поколений, вернуться к шагу 2 (условием достаточности считается отсутствие улучшения приспособленности лучшей особи популяции в течение maxGenerations поколений);
8. Конец.

Создание объекта класса Population происходит с помощью конструктора, где:

− minValue – минимальное значение интервала;

− maxValue – максимальное значение интервала;

− maxPopulationSie – максимальный размер популяции;

− crossPossibility – вероятность кроссинговера;

− mutationPossibility – вероятность мутации;

− initPopulationSie – начальный размер популяции;

− txtFunction – целевая функция;

− fitnessFunction – фитнесс-функция;

− isMaxExtremum – признак поиска максимума глобального экстремума, если true, и поиск минимума глобального экстремума, если false.
 
Генетический алгоритм не дает чудесное решение для всех задач минимизации/максимизации. Нередко другие алгоритмы быстрей и удобней. Однако для задач с большим пространством параметров, где сама задача с легкостью точно определяется, генетический алгоритм является подходящим решением. Можно и дальше улучшать алгоритм, реализовав всевозможные операторы скрещивания, мутации и селекции.
